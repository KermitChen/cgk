package com.dyst.oracle;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.*;

import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.ResultSetHandler;
import org.apache.commons.dbutils.handlers.BeanListHandler;
import com.dyst.entites.Sbnew;
import com.dyst.utils.InterUtil;
/**
 * 实现Oralce查询
 * @author likui
 */
public class OracleSearch {	
	/**
	 *查询类型1
	 * 功能描述: 查询特定车牌类型的历史轨迹<br>
	 * sql:查询语句   <br>
	 * from 起始查询记录<br>
	 * pagsize:每页显示记录数<br>
	 * sort : 排序字段<br>
	 * sortType 排序类型<br>
	 * @throws SQLException <br>
	 * @return 识别记录对象列表
	 */	
	@SuppressWarnings("finally")
	public static List<Sbnew> TDCPGJCX(String sql, int from, int pagsize, String sort, String sortType) throws SQLException{
		//过滤特殊字符  ==============
//		sql = InterUtil.keyWordFilter(sql);
//		sort = InterUtil.keyWordFilter(sort);
//		sortType = InterUtil.keyWordFilter(sortType);
		
		//连接数据库
		DBConnectionManager dbCon = DBConnectionManager.getInstance();
		Connection connection = dbCon.getConnection("db");
		String orderStr="";//排序字段与类型
		//执行查询
	    List<Sbnew> listTxsj = new ArrayList<Sbnew>();
		try {
			QueryRunner qr = new QueryRunner();
			//oracle不能 分页查询，同时排序，除非使用再嵌入一层的查询方式. 单数据量大时效率较低
			//另一种解决方法，对排序的字段进行主键或者索引，即可先按该字段排序。然后再rownum,方法不变
			//因识别表时用tpid1做主键，且以通过时间为生成序列，故在此使用tpid1进行排序
			if(!"".equals(sort.trim()) && !"".equals(sortType)){//生成排序sql
				orderStr = " order by tpid1 " + sortType ;
			}
			
			if(pagsize != 0){//如果起始查询记录和每页显示记录数不为0，分页查询
				sql = "SELECT * FROM (" + sql + " and ROWNUM <= " + (from + pagsize) + orderStr +") WHERE rn > " + from;
			} else{
				sql += orderStr;
			}

			listTxsj = (List<Sbnew>)qr.query(connection, sql, new BeanListHandler<Sbnew>(Sbnew.class));
		} catch (Exception e) {
			e.printStackTrace();
			throw new SQLException("Oracle数据库查询异常");
		}finally{
			if(connection!=null){
				dbCon.freeConnection("db", connection);
			}
			
			//分页查询
            return listTxsj;
		}
	}
	
	/**
	 * 功能描述: 按照指定sql语句返回查询记录总数
	 * @throws SQLException 
	 */	
	@SuppressWarnings("finally")
	public static Integer getTDCPGJCXCount(String sql) throws SQLException{	
		//连接数据库
		DBConnectionManager dbCon = DBConnectionManager.getInstance();
		Connection connection = dbCon.getConnection("db");
		Long count = null;
		try {
			QueryRunner qr = new QueryRunner();
			count = qr.query(connection, sql, new ResultSetHandler<Long>(){
				public Long handle(ResultSet rs) throws SQLException {
					if(rs.next()){
						Long len = rs.getLong(1);//或者rs.getLong("count")
						return len;
					}
					return 0L;
				}
			});
		} catch (Exception e) {
			throw new SQLException("Oracle数据库查询异常");
		}finally{
			if(connection != null){
				dbCon.freeConnection("db", connection);//归还连接池连接
			}
			if(count == null){
				return 0;
			}
			return count.intValue();
		}
	}
	
	/**
	 * 更新Oracle识别记录
	 * tpid1 图片id
	 * cphm1 修改后的车牌号码
	 * cplx1 修改后的车牌类型
	 */
	@SuppressWarnings("finally")
	public static String updateOracleSb(String tpid1, String cphm1, String cplx1) throws Exception {
		DBConnectionManager dbCon = DBConnectionManager.getInstance();
		Connection connection = dbCon.getConnection("db");
		Statement st = null;
		String sql = "";
		String result = "1";
		try {
			//车牌号码及图片id不能为空
			if(tpid1 != null && !"".equals(tpid1.trim()) && cphm1 != null && !"".equals(cphm1.trim())){
				//如果车牌类型null，则置为空字符串
				if(cplx1 == null){
					cplx1 = "";
				}
				
				//特殊字符过滤
				cphm1 = InterUtil.keyWordFilter(cphm1);
				cplx1 = InterUtil.keyWordFilter(cplx1);
				tpid1 = InterUtil.keyWordFilter(tpid1);
				
				//新表结构
				sql = " update SB set cphm1 = '" + cphm1 + "', cplx1 = '" + cplx1 + "' where tpid1 = '" + tpid1 + "'";
				
				st = connection.createStatement();// 操作数据库
			    st.execute(sql); // 更新记录
			} else{
				result = "0";
			}
		} catch (Exception e) {
			result = "0";
			e.printStackTrace();
			throw new Exception(""+e.getMessage());
		} finally {
			if(st != null){
				try {
					st.close();
				} catch (SQLException e) {
					e.printStackTrace();
				}
			}
			if(connection != null){
				dbCon.freeConnection("db", connection);
			}
			
			return result;
		}
	}
}